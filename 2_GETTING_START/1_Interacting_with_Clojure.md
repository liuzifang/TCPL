#Section 2.1. 与Clojure对话

所有的Lisp语言实现都提供了自己的REPL程序，REPL也就是"read-evaluate-print-loop"的缩写，即“读入-运算-输出-的循环”程序。它的存在表示你可以直接向它输入一个表达式，它会直接运算并把运算结果返回给你。Clojure作为Lisp家族的一员，当然不会违背这一传统。

你可以在REPL中输入任何对于Clojure语言本身合法的语句，然后得到结果。你甚至可以把整个程序都在REPL中完成，只要你不嫌麻烦。你也可以在REPL中加载你在外部用编辑软件书写的Clojure程序，然后在REPL中一一测试，因为对与读入这一操作而言，相当于你在REPL中输入了那些你在文本中输入的表达式。

所以你要好好利用REPL这种东西，它可以验证你的猜想，可以帮助你排错，总之有很多有益的操作都依赖于REPL的存在。

> java -cp clojure-1.5.1.jar clojure.main ;当你安装设置好了jdk，同时下载过了clojure之后，使用这条命令启动REPL，jar文件在实际情况下需要jar文件真实存在的地址，而不是在所有情况下都照抄一遍。

当你启动REPL之后，你可能会看到下面这样的语句:
> user=>

在'=>'后面就是你输入表达式的地方了，让我们试着输入一个表达式
> user=> "Hi Clojure!"  
"Hi Clojure!"

REPL返回了它的运算结果，那个什么额外修饰都没有的“Hi Clojure!”就是我们输入的表达式的运算结果。在以后的例子里，为了表达方便，我将用";=>"来表示运算结果所以不要把这些以及之后的内容也输入到repl中，而表达式的"user=>"将被我省略。

我们现在来看看更多表达式，以及他们的运算结果吧，不要忘了自己亲手输入试试。
> "hi"  ;=> "hi"  
  11  ;=> 11  
  23/7  ;=> 23/7  
  3.14  ;=> 3.14  
  -  ;=> #&lt-&gt  ;实际的返回并不是这种形式，但是在第一章中我们说过书中将采用这种表示方法  
  (+ 1 2)  ;=> 3  
  (* 2 3)  ;=> 6  
  (- 1 -1) ;=> 2  
  '(1 2 3 4) ;=> (1 2 3 4)  ;不要忘了表达式的单引号，否则你会得到一个错误

在上面例子中的最后几个表达式中千万不要少了括号或者引号，前者会导致repl将一直等待缺少的那个括号，而后者则将直接无情的报错。

现在我们可以尝试一下更为复杂的表达式。我并不打算把这些表达式的用意说出来，你不妨自己根据结果来猜猜这些运算的含义，或者你可以懒到直接在后面的章节中看我说出答案。
```clojure
(first '(1 2 3))  ;=> 1  
(rest '(1 2 3))  ;=> (2 3)  
(cons 1 '(2 3))  ;=> (1 2 3)
(cons (first '(1 2 3))  
  (rest '(4 5 6))) ;=> (1 5 6)
```

你现在看到了，一个表达式的确是可以跨越多行的，而且表达式里面还可以嵌套表达式，这也就是我们之前所提到的结构体，即那些非一维的表达式或纯粹的表。不过在这一过程里要非常两个括号之间的匹配，不要把括号漏掉或者方错了位置。当你熟练的时候这种错误几乎不可能出现，但是作为新手，请务必十二万分的小心。

接下来，我们来定义一个原始函数。所谓原始函数意味着在实际情况下，我们使用更简洁但是不够规矩的方法来定义函数，只是在这里，我们需要规矩。
```clojure
(def square (fn [x] (* x x)))  ;=> #<square>
```

这个叫做'square'的函数接收任一个数作为X，然后计算出x的平方。其它函数的定义方法我们之后再说。上面的那个表达式中，'def'用来建立一个绑定，将'(fn [x] (* x x))'绑定到标识符'square'上。而第二层的那个表达式，'fn'用以创建一个函数。而第三层的'*'标识符绑定了一个负责乘法的函数。

仔细注意那三个表达式的形式，所有的表达式都被包裹在一对括号里，而在括号里，放在第一位的必然是一个函数性质的存在，比如'def','fn','*'，而在第一个空格的后面，则是被空格分割开的各个参数。对于'def'而言，'square'和整个第二层的表达式就是它的参数。对于'fn'而言，'[x]'和'(\* x x)'就是它的参数。而对于'\*'，自然，两个'x'就是它的参数。

现在让我们来尝试着使用'square'这个函数
```clojure
(square 3)  ;=> 9  
(square -2)  ;=> 4  
(square -1/3)  ;=> 1/9
```

虽然我们接下来的这个函数定义很短，但是我们仍然可以将之写在一个文件之中。我们创建一个叫做“one.clj”的文件，然后在里面输入这些内容
```clojure
(def one?  
  (fn [x]  
    (if (= x 1)  
      true  
      false)))
```

这个叫做'one?'的函数接收一个参数作为x，如果这个参数是1，那么运算结果就是'true'，反之，为'false'。

保存文件之后，在REPL中输入
```clojure
(load-file "one.clj")  ;=> #<one?>  ;注意双引号中的应该是文件的实际路径
```

除了这种方法之外，你也可以在你启动REPL的命令后面加上clojure文件的路径直接运行。但是我们的one.clj文件只是定义了一个函数而已，所以这种用法在此刻显得毫无意义。

回归到我们在repl中的情况，加载了'one.clj'之后，我们开始试试这个函数吧
```clojure
(one? 1)  ;=> true  
(one? 2)  ;=> false  
(one? -1)  ;=> false  
(one? (first '(1 2 3)))  ;=> true
```

在下面的章节中，我们将探讨更多的Clojure表达式的细节，直到本章结束。你应该在脑子里记住**"REPL对于你学习lisp或者clojure，使用lisp或者clojure都是十分有用的工具"**。无论你得到了怎样的创意，都应该先在REPL中测试一番，然后在放到你真正的代码中，即便你可能会因此多花费些时间，但请相信我，这种付出是绝对值得的，与其在代码中无来由的出错，何不先测试一番呢？
