#Section 2.2. 简单的表达式

在Clojure和几乎所有的Lisp中，最简单的表达式应该就是常见的数据主体，比如字符串，数字，符号还有作为数据的表。Clojure当然也支持更复杂的数据结构，但是以上四种数据类型对于很多程序而言都是足够的了。在前面的章节里，我们也已经尝试过把字符串和数字当成表达式输入进REPL中会得到怎样的结果了。

现在，我们要讨论更多关于数字的细节。首先，数字是个常见的量，而且，它可以作为表达式，当你对REPL输入数字时，REPL有回应了你一个一模一样的数字。下面的例子是几个常见的数字类型
> 123  ;=> 123  ;整数  
  1/2  ;=> 1/2  ;分数  
  0.618  ;=> 0.618  ;小数/浮点数  

还有一些其它的数字类型，这会根据你所使用的寄生平台而有区别，但总的来说，你使用什么平台就能得到那个平台所有的数字类型。

Clojure使用 +,-,*,/ 四个函数来完成数的最基本四则运算。以下，是这些运算的几个例子
> (+ 1/2 1/2)  ;=> 1  ;实际结果应该是1N，此处当作1  
  (- 1.5 1/2)  ;=> 1.0  
  (* 3 1/2)  ;=> 3/2  
  (/ 1.5 3/4)  ;=> 2.0  

对于Clojure使用的S表达式(姑且理解为前缀表达式)而言，凡第一位的必是函数，而函数后面的都是参数，在其它语言中的'1+1+1'的语句在Clojure中怎么写，难道要写成'(+ 1 (+ 1 1))'么？当然不，'+'作为一个函数，在设计它的时候，就准备好了多参数的情况,如下
> (+ 1 1 1)  ；=> 3

这并不是什么语法糖，而是一种很规矩的写法，‘+’这个函数本来就可以接收多个参数，而不是为了简写而做的无理由的语法糖。

有的时候，即使是四则运算也会复杂，对于这种情况，我们就会将表达式层层嵌套，而嵌套起来的可运算的表达式，就是结构体。
> (- 2 (* 3 (+ 2 1)))  ;=> -7

除了四则运算之外，还有其它的很多函数可以进行计算，但是本质上，用法上，它们和这四者并无分别。

当你书写了这么多的表达式之后，会不会有一瞬间觉得这些表达式很像列表？其实它们不但像，它们就是列表，只是可以运算。

在Clojure中所谓表，就是各种表原子和表本身或者说一对括号组成的东西。比如一个表'(atom1 atom2 atom3)','()'就是表本身，里面的各种atom就是表原子。

表通常有两种形态，数据态与执行态。‘(+ 1 1)’在你为了计算1+1而输入进REPL中的时候，它就是作为执行态表达的，而它的数据态是什么呢，也是'(+ 1 1)'，只不过运算结果是返回它本身，你不能直接这样输入进REPL中，因为这样的表达式默认为执行态输入。如果你想将它作为数据态你需要这样输入:
> '(+ 1 1)  ;=> (+ 1 1) ;不要忽略单引号

那么有没有不存在执行态的表呢？当然有，我们称这些表为数据表，比如'(1 2 3)'，比如'("this" "is" "a" "list")'，你可以尝试着将这两个表输入到repl中看看会得到什么结果。

毫无疑问，REPL报错了。为什么错？我们说过，当你输入进REPL中，或者作为程序执行的时候，所有的表都默认是执行态，而执行态中，表的第一位必然是一个函数，而'(1 2 3)'和'("this" ...)'两个表中，它们的第一位是什么？是一个函数么？

联想到'(+ 1 1)'是如何以数据态被输入的，我们应该知道，如何把那两个表以数据态输入
> '(1 2 3)  ;=> (1 2 3)  
  '("this" "is" "a" "list")  ;=> ("this" "is" "a" "list")

单引号其实是一个宏语句，你姑且理解为简写。它的原形是(quote ...),'(1 2 3)等价于(quote (1 2 3))，其输入的结果等价于(list 1 2 3)。‘list’是一个函数，返回它所接收到的参数所组成的数据表。

Clojure或者说Lisp中，几乎所有的存在都可以被'quote'
> '1  ;=> 1  
  '("a")  ;=> ("a")  
  '2/3  ;=> 2/3  
  '(/ (* 2 -1) 3)  ;=> (/ (* 2 -1) 3)

看下面这个比较
> 1  ;=> 1  
  '1  ;=> 1

两个表达式都返回了1，那么，这两个表达式是不是同样的意思呢？当然不。当你输入1的时候，REPL接收到的是一个执行态的表达式，REPL对1进行运算，1的运算结果是什么呢？是1,这个1是运算得出的1，不是你所输入的1。而对于'1，REPL接收到的是一个数据态的表原子，对于数据态的东西REPL会对其进行运算么，假设你是REPL，对方说了这个不需要运算，你会手脚麻利到自作主张对这个表达式进行运算么？当然不，REPL的确也输出了1，但这个1就是你所输入的那个数据1，而不是前者那个表达式中以执行态出现并运算得出的1。

接下来，我们来讨论两个Clojure中数据表处理最常用的函数，first和rest也就是其它一些lisp中的car,cdr。first函数，会取出表的第一个原子，而rest,顾名思义，取出除了第一个原子之后的所有原子，并将它们放在一个新表中。
> (fisrt '(1 2 3))  ;=> 1  
  (rest '(1 2 3))  ;=> (2 3)  
  (rest '())  ;=> ()  
  (first (rest '(1 2 3)))  ;=> 2  
  (rest (rest '(1 2 3)))  ;=> (3)

对于上面第三个例子中，为什么'()的取出剩下元素操作会得到'()'呢？因为'()中没有原子了，所以rest操作取出了一个不存在的原子，然后把这个不存在的原子放在了新的表中，返回的'()'就是这个新表，新表中有一个不存在的原子。

还有下面的例子
> (first '((1 2) (3 4)))  ;=> (1 2)
  (rest '((1 2) (3 4)))  ;=> ((3 4))

对于第二个例子，(3 4)就是rest操作取出的原子，虽然它们是一个表，但是对于外层的表而言，它们是原子，于是作为原子，将它们放进一个新表。不光是执行态的表可以构成结构体，数据态的表既然和执行态的表拥有同样的表达方法，它们当然也可以构造称结构体，但这种结构体只是有结构的数据，并不能执行，当然，也有例外。

所谓例外，就是这样一个事实，所有的Clojure表，都拥有数据态，但并非所有的表都拥有执行态。即我可以从“它是Clojure的表”得出“它拥有数据态”的结论，而不能得出“它拥有执行态”的结论。

现在我们来看第三个函数cons,它接收两个参数，把第一个参数作为原子，添加到第二个参数的头部。
> (cons '1 '())  ;=> (1)  
  (cons '1 '(2 3))  ;=> (1 2 3)  
  (cons '(1 2) '(3 4))  ;=> ((1 2) 3 4)  
  (cons (first '(1 2 3)) (rest '(1 2 3)))  ;=> (1 2 3)

还有另一个函数conj它的作用和cons相似，但是它把第二个参数作为原子，添加到第一个参数中，如果第一个参数是矢量就放在尾部，是列表则放在头部。而cons其实会将第二个参数在能转换为列表的情况下先转为列表，再把原子放在该表头部。
> (cons '1 [1 2 3])  ;=> (1 1 2 3)  
  (conj [1 2 3] '1)  ;=> [1 2 3 1]  
  (conj '(1 2 3) '1)  ;=> (1 1 2 3)

[]是不需要'的，因为[]不是表，它是表(vector ...)的简写，不存在执行态。其实'1也是可以不写'的，因为两者的运算结果都是1，但下意识里，可能觉得在这里写上'会更规矩一些。通常在开发中，作者本人是向来不会加上这个'的。

最后来看看list这个函数，它以执行态的方式通过运算生成一个列表。
>(list 1 2 3)  ;=> (1 2 3)

那么，它与'(1 2 3)有什么区别呢？如同'1与1的区别一样。'(1 2 3)返回的是你输入的数据表，list返回的是新生成的数据表。而且在开发的过程中，所有需要生成表的地方，都只能使用list而不可能使用quote。因为quote的内容全是数据，而list则全是可运算的。

###Exercise 2.2.1
将下面的中缀表达式转换成Lisp族语言所使用的S表达式,并在repl中验算结果是否和原表达式一致
> 2*(1 - 1/2)+(-1)  
  5 / (2*3-1) + 2

###Exercise 2.2.2
试试看把不同类型的参数放在四则运算中会得到怎样的结果，比如(+ 1 "2")，然后尝试着思考为什么会得到这样的结果。

###Exercise 2.2.3
判断以下表达式的值，然后在repl中验证
> * (cons 'car '(cdr))  
  * (list 'this '(is funny))  
  * (cons 'this '(is funny))  
  * (quote (+ 1 (* (- 8 2))))  
  * (cons '+ '(1 1 1))  
  * (+ 1 1 1)  
  * (first '(+ 1 1 1))  
  * (first '(+ - * /))  
  * ((first (list + -)) 1 1 1)  
  * ((first '(+ -)) 1 1 1)

###Exercise 2.2.4
思考为什么Exc2.2.3中最后一个表达式会报错。

###Exercise 2.2.5
有一个数据表((1 2) (3 4)),用(first (first '((1 2) (3 4))))可以取出1，你来写出三个表达式，分别取出这个数据表的 2 , 3 , 4。

###Exercise 2.2.6
对于一个空表()，对其分别进行first和rest操作会得到什么结果？为什么会得到这样的结果？
