#Section 2.4. 变量和Let表达式
如果我们面对这样一种需求，一个表示为expr的表达式保存在一个变量var中，当我们输入var的时候，运算出expr的结果，我们应该怎么做？或者更常见一些的，我要用x表示1，然后来计算(+ x 1)，同时要让这个表达式的结果为2，我该怎么做。有两种方法，我们先说局部使用的那种，let表达式。

(let [var expr] var)这个语句是伪代码，但它确实在局部上实现了用expr保存var。

第二个需求,(let [x 1] (+ x 1))这个表达式输出2。

let表达式由两部分组成，一个是放在[]中的变量-表达式对，另外一部分就是在[]后面的表示具体操作的表达式。它的通用形式应该是
```clojure
(let [var expr var1 expr1 ...] body body1 ...)
```

let表达式中，[]里面的内容意味着什么呢？var和expr绑定在了一起，你输入了var就等于是输入了expr。在实际情况下，你甚至可以说，将var和expr的值绑定在了一起，你输入了var就得到了expr的值。

让我们再来看一段代码
```clojure
  (let [list1 '(1 2 3) list2 '(4 5 6)]  
    (cons  
      (cons (first list1) (rest list2))  
      (cons (first list2) (rest list1))))  
      ;=> ((1 5 6) 4 2 3)
```

函数也理所当然可以绑定在新变量上
```clojure
(let [a +]  
  (a 1 1))  ;=> 2  
(let [a + x 1]  
  (a x 1))  ;=> 2  
(let [a + x 1 y 1]  
  (a x y))  ;=> 2
```

let中绑定的变量只能在let的领土内生效
```clojure
 (let [thisvariserror 1]  
  (+ thisvariserror 1))  ;=> 2  
 thisvariserror  ;=> error
```

当你在let外部输入let内部定义的变量时，repl无情的报了个错，这是合情合理也很有好处的设定。你也不希望别的国家来干涉内政吧？

let语句也是可以嵌套的，而且在这一过程中，仍然遵守let内的变量在let领土内生效这一约定。
```clojure
(let [x 1]
  (let [x (+ x 1)]
    (+ x x)))  ;=>4
```

外层的let表达式在它的领域中将x和1绑定在一起。内层的let表达式在它的领域中将x和(+ x 1)绑定。但(+ x 1)值是什么呢？在内层的表达式绑定过程中，所能读取到的唯一的x的值是外层let表达式所绑定的x，所以x的值为1，(+ x 1)的值为2。当内层表达式绑定的过程完成后，在内层x的值是什么呢？是2。所有(+ x x)等于4。

但是外层的x的值到哪去了，还存在么？还是已经不存在了？外层的x当然存在，且始终在外层的领土内生效，但是对于内层而言，内层的领土在外层的领土中，只是同样绑定了一个新的x，这个x遮住了外层的x，且内层的x仅在内层生效，如果内层没有绑定x，而是别的变量，那么外层的x仍然在内层生效。我们称变量可生效的范围为变量的作用域。

对于上面的例子而言，内层x的作用域是外层x作用域的一部分，外层x一直在内层作用域中生效，但在内层的作用域中被内层x遮盖。下面的例子或许有助于理解。
```clojure
(let [x 1]
  (let [a (+ x 1)]
    (+ a a x)))  ;=> 5
```

如果内层没有定义x的话，生效的则是外层x的值，因为内层的作用域是外层的子集，若无覆盖，外层当然在内层生效。

###Exercise 2.4.1
判断下面这个表达式的返回值，并说明为何做此判断，然后在repl中验证答案
```clojure
(let [x 9]
  (* x
    (let [x (/ x 3)]
      (+ x x))))
```

###Exercise 2.4.2
改写下面两个存在遮盖现象的表达式，让他们不出现作用域的遮盖现象，并且运算结果要与之前的表达式一致。
```clojure
;a
(let [x 'a y 'b]
  (list
    (let [x 'c] (list x y))
    (let [y 'd] (list x y))))
;b
(let [x '((a b) c)]
  (list
    (let [x (rest x)]
      (first x))
    (let [x (first x)]
      (list
        (let [x (rest x)]
          (first x))
        (list
          (let [x (first x)] x)
          (rest x))))))
```
