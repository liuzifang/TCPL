#Section 2.5. Lambda表达式
(let [x 1] (+ x x))，在这个表达式中1被绑定在变量x上。如果我们需要计算很多个(+ x x)，但是需要x和99绑定，和103绑定，和24绑定，和任何数绑定，我们该怎么办？每要绑定一次便写一个let表达式么，那还不如直接写(+ 1 1)，(+ 103 103)...方便。

为了解决这种需求，我们可以使用lambda表达式来创建一个函数，只需要传入x所要绑定的值即可得出结果。lambda表达式和let表达式的书写基本没有什么差别。
```clojure
(fn [x] (+ x x))  ;=> #<>  ;在clojure中,fn取代了其他几乎所有lisp使用的lambda，本质上没有区别，只是少打几个字母。
```
lambda表达式的通用形式和let也基本一致
```clojure
(fn [var ...] body body1 ...)
```

被[]包裹的是各种变量var...，而body...就是lambda表达式的具体运算流程。

一个函数主体的值和数字，字符串，符号，列表之类的主体的值没有任何区别。但是后者的值都可以被打印出来，因为他们是可以具现出来的，但是函数的值不行，我们没有办法表式它，所以我们用#<>来表示这个函数的值，函数要是叫fun，我们就用#<fun>来表示它。lambda返回的函数没有被绑定，所以这个函数没有名字，我们就直接用#<>来表示它。

对于一个函数，最常见的用法就是应用它，并传入参数。
```clojure
((fn [x] (+ x x)) (/ 9 3))  ;=> 6
```

这个表达式和我们之前看到的函数应用表达式并没有什么区别。lambda表达式的运算结果是一个表示函数主体的值。+的运算结果是什么？是不是代表加法函数的值？表的第一位会被作为函数执行，将后面的东西当成参数传递给函数。第一位是什么？lambda表达式的运算结果。运算结果是什么？一个函数。一个函数放在表的第一位，理所当然被调用，而后面的(/ 9 3)被算出3，然后传递给这个函数，得出6。

一个函数究竟是什么？它可以看作是流程的主体，就如同一个数，是由这个数的值表示的主体。一个函数，和一个数对于clojure而言，在本质上有没有区别？没有。clojure只看你的位置，而不在乎你是什么。犹如我需要在门框里放一个门槛，一块木头也好，一个铁条也好，我不管你们在别的地方有多大的区别，我也不管你们在别的地方是什么东西，一旦落在我的门框下面，你们就是我的门槛，我也把你们当作门槛来用。

看这段代码
```clojure
(let [double (fn [x] (+ x x))]
  (list 
    (double 1)
    (double (* 1 2))
    (double (+ 1 2))))  ;=> (2 4 6)
```

对于clojure而言，函数和其他东西既然没有区别，当然也能像其他东西一样使用。我们在这个表达式里将double与函数绑定，然后我们就将double放在了函数的位置上，反复使用了三次，每一次都没出现任何问题。

再来看一段
```clojure
(let [double-list (fn [x] (list x x))]
  (double-list 1))  ;=> (1 1)
```

注意double和double-list之间的相似性。我想你应该不会惊讶于下一个例子中把函数当参数的情况。
```clojure
(let [any (fn [f x] (f x x))]
  (list
    (any + 1)
    (any list 1)))  ;=> (2 (1 1))
```

上面的例子中，lambda返回的函数接收了两个参数，而且有一个是流程主体。之后在函数内部，接收到的流程主体被调用成为函数又接收了外层函数接收的另一个值。

let和lambda表达式在有嵌套条件的时候，会发生一些有趣的事情
```clojure
(let [x 1]
  (let [f (fn [y] (list x y))]
    (f 2)))  ;=> (1 2)
```

lambda表达式中的x引用了最外层let表达式中x所绑定的值。这是因为lambda表达式存在于最外层的let中，而一个变量在它的作用域中是通行无阻的。即使是在lambda中，x仍然生效，因为lambda在最外层let中，而x的作用域是整个最外层let。至于y，则只能在lambda中生效，因为它是在lambda中绑定的，它的作用域，也仅在lambda中。要记住*变量在变量的作用域中通行无阻，即使是出现遮盖现象，也不能说原有变量在这个作用域中失效*。

如果，一个函数在一个变量的作用域内，在这个函数内部维持着这个变量，当这个函数在这个变量的作用域外被调用，会发生什么，就像下面这样。
```clojure
(let
  [f
   (let [x 1]
    (fn [y z] (list x y z)))]
  (f 2 3))  ;=> (1 2 3)
```

答案就是这个变量仍然有效。即使这个函数是在这个变量的作用域外被调用，只要这个函数维持了这个变量，那么只要这个函数可以被调用，无论什么条件，这个变量都会生效，即使这个变量在函数被调用的地方从来都没出现过。

如果在函数调用的地方，是另外一个同名变量的作用域，函数会使用所保持的变量还是调用时的变量呢？
```clojure
(let
  [f (let [x 1] (fn [y z] (list x y z)))]
  (let [x 4]
    (f 2 3)))  ;=> (1 2 3)
```

返回的结果中x仍然是1而不是4。

顺便一提，let表达式的行为和对lambda表达式调用并赋值的行为并没有什么区别，或许底层实现并非如此，但那已经脱离了我们的讨论范畴了。来看下面两个表达式。
```clojure
(let [x 1] (+ x x))
((fn [x] (+ x x)) 1)
```

两者之间不管怎么理解，仿佛都是一回事吧。所以我们可以近似的推导出，let表达式是基于lambda表达式的扩展。两者之间有如下对等的通用格式
```clojure
(let [var expr ...] body ...)
((fn [var ...] body ...) expr ...)
```

就如我们之前提到的"近似推导"，lambda表达式其实要比我们之前所写的那些例子在参数接收上要更为复杂。除了之前所看到参数传入之外，还能通过匹配，指定的方式传入限定数量和不限定数量的参数。

* 限定参数的普通传入方式我们已经见过了，就是 [var1 var2 ...]
* 不限定参数的形式是 [var1 \& var2]
* 匹配参数的形式是 [[var ...] var ...]
* 指定参数的形式则是 [{var varkey...}]

对于第一种情况来说，有多少变量就需要传入多少参数，变量和参数按照各自的顺序一一对应并绑定。

第二种则是\&前面有多少变量就一一对应传入多少参数，而剩下的所有参数会组成一个表绑定到\&后面的唯一一个变量上。

第三种，则是参数的组成结构和变量结构一致，则被匹配赋值，我们会在下面的内容中看到实例。

第四种，就是在赋值的时候指定一个key，将参数传给对应这个key的变量。

以下是上述内容的一些实例
```clojure
(let [f (fn [& x] x)]
  (f 1 2 3 4))  ;=> (1 2 3 4)

(let [f (fn [& x] x)]
 (f 1))  ;=> (1)

(let [f (fn [x & y] (list x y))]
  (f 1 2 3 4))  ;=> (1 (2 3 4))

(let [f (fn [a b & c] (list a b c))]
  (f 1 2 3 4)) ;=> (1 2 (3 4))

(let [f (fn [x {y :pasy z :pasz}] (list x y z))]
  (f 1 {:pasz 2 :pasy 3}))  ;=> (1 3 2)
```

对于最开始的两个例子，被绑定在f上的函数可以接收任意多的参数，即使是0个参数，x也会绑定上空表。对于再往后的两个例子，\&符号前的变量一一对应，\&的唯一一个变量将把所有剩余参数都接收放在一个表里。这其实相当于你仍然接收了你定义时指定数量的变量，只是最后一个变量是个隐式生成的表而已。这也就是为什么在第二个例子中传入一个变量1却得到'(1)的原因。

对于最后一个例子，我们并没有说过映射，所以现在就简单说说，在{}中变量与匹配于该变量的关键字组成一对，当你在赋值的时候，你仍然要使用{}，但是变量与变量关键字的顺序与在定义是相反，你可以任意书写变量的顺序，却只会将变量值绑定到对应该变量关键字的变量上。在绑定过程中，:pasz得到2，它匹配的是z，所以变量z绑定2，而:pasy虽然是后一个赋值的，但它仍然将变量值绑定到y上，这也就是(list xy z)得出(1 3 2)的原因。

### Exercise 2.5.1
判断下面表达式的值
```clojure
;a
(let [f (fn [x] x)]
  (f 'x))
;b
(let [f (fn [& x] x)]\
  (f 'x))
;c
(let [f (fn [x & y] x)]
  (f 'x))
;d
(let [f (fn [x & y] y)]
  (f 'x))
;e
(let [f (fn [{x :pasx y :pasy z :pasz}] (list x y z))]
  (f {:pasz 'x :pasx 'y :pasy 'z}))
```

### Exercise 2.5.2
我们看过let,看过fn，但是没有哪个函数是可以直接在let外面用的，那么猜猜看，list函数是怎么被定义出来的呢？

### Exercise 2.5.3
列出下面lambda表达式中出现的所有标识符(变量？)。不要忽略那些已经被绑定过的标识符,也不要在意这些表达式是否正确。
```clojure
(fn [f x] (f x))
(fn [x] (+ x x))
(fn [x y] (f x y))
(fn [x]
  (cons x (f x y)))
(fn [x]
  (let [z (cons x y)]
    (x y z)))
(fn [x]
  (let [y (cons x y)]
    (x y z)))
```
