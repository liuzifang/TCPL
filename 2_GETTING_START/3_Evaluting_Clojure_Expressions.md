#Section 2.3. 求取Clojure表达式的值

我们现在来谈谈Clojure是怎么计算你输入的表达式的。我们已经说过了你输入一个固定的量时，Clojure会如何回复你，比如，字符串，数字。Clojure会回复给你一个看起来一模一样的值。

比如这种形式的表达式(function arg1 ... argn)，在你可能已经在脑子里大致明白了它被调用时的运算规则。你要仔细看下面这一段话,**function是一个表达式，它表示一个Clojure的函数，每一个arg也都是表达式用来表示它们各自的参数。

我们首先要明确，几乎所有的语句都是表达式，这个表达式在运算时的过程大致是这样的。
> * 找到function的值  
  * 找到arg1的值  
    
  * 找到argn的值  
  * 将arg1...argn的值应用到function的值上

举个例子，我们之前反复使用的 (+ 1 1)。+ 是什么？ + 是标识符。当 + 在运算时是什么？是一个单由标识符组成的表达式。这个表达式的运算结果是什么？是一个实现将参数相加的函数。后面两个1是什么？ 是数字。数字在运算时是什么？是单由数字组成的表达式。其结果是什么？是其本身的值。

我们取出+的值，取出1的值，是不是直接就算出2了？不是。

只有当+的值被应用的时候，而且1被传入的时候，我们才能算出2。

+的值怎么才能被应用？我们把+,1,1这些东西当成是内层的表达式，而(+ 1 1)是最外层的表达式。当+的值放在一个执行态的表的第一位时，这个值会被当成函数并调用，在这个表后面的所有表达式的值被当作第一位函数的参数。

那么，有没有不遵循上述这些规则的语句呢？有，且仅有一个--(quote ...)。还记得这个表达式的作用么？它会解除一个表的执行态，它不会被运算。比如(+ '1 '1)，后面的两个1不会再被当成需要运算的表达式了，而直接被当成运算结果1，然后被应用到+所得出的运算结果加法函数上。

那么('+ '1 '1)会的得到什么样的结果呢？在clojure-repl中输入的结果是正常运算出2。但其实这是Clojure的一种优化处理，首先这个语句你绝对不会在实际开发中想到书写它，第二点，如果Clojure没有进行优化，它应该会报错。

为什么说它是错的。我们在repl中输入'1时得到1，输入'+时会得到什么？得到+。那么我们输入+会得到什么？#<+>。'+和+的值不是一样的，'+没有执行态，它的结果是标识符本身，不是函数，但它却放在了函数的位置上，而+也是标识符，但它是具有执行态的，它的执行结果是标识符绑定的加法函数。你不妨细细体会其中的差异。

固定值组成的表达式，函数表达式，还有quote表达式，这可以说是Clojure的全部语法形式了。几乎所有的语句都脱离不了这三种形式或这三种形式的组合。

在我们向下面的章节继续深入之前，要记住表达式的运算规则，由内而外，从左到右。以之前function的表达式来说，所谓由内而外，即我们会先计算function,arg1...argn这些表达式，而不是(function arg1 ... argn)这个表达式，所谓从左到右，是指我们会先计算function的值，然后才会计算arg的值。当内部的表达式算好之后我们会得到一个我表示为(#<function> arg1的值 ... argn的值)的表达式，然后因为#<function>在第一位，所以它被调用，其它位的存在被当成参数，传递给调用的#<function>。

###Exercise 2.3.1
写下下方表达式的具体运算步骤
> ((first (rest (list * / + -))) 18 6)
